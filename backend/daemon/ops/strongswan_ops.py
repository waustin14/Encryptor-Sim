"""strongSwan configuration operations.

Generates and writes peer connection configurations to
/etc/swanctl/conf.d/ for strongSwan IKE daemon.
"""

import logging
import re
import subprocess
import time
from collections.abc import Callable, Iterable
from pathlib import Path

logger = logging.getLogger(__name__)

Runner = Callable[..., subprocess.CompletedProcess]


def _sanitize_name(name: str) -> str:
    """Sanitize a peer name for use as a strongSwan configuration identifier.

    Replaces spaces and other non-alphanumeric characters (except hyphens
    and underscores) with underscores to produce a valid swanctl identifier.
    """
    return re.sub(r"[^a-zA-Z0-9_-]", "_", name)

SWANCTL_CONF_DIR = "/etc/swanctl/conf.d"
CT_NAMESPACE = "ns_ct"


def _swanctl_cmd(*args: str) -> list[str]:
    """Build a swanctl command that runs inside the CT namespace."""
    return ["ip", "netns", "exec", CT_NAMESPACE, "swanctl", *args]

_PEER_NAME_CACHE: dict[str, int] = {}
_PEER_CACHE_LAST_REFRESH: float = 0.0
_PEER_CACHE_TTL_SECONDS = 5.0


def _is_already_established(output: str) -> bool:
    """Detect idempotent initiation messages from swanctl output."""
    lowered = output.lower()
    return (
        "already installed" in lowered
        or "already established" in lowered
        or "already up" in lowered
    )


def _load_peer_name_map() -> dict[str, int]:
    """Load peer name -> peerId mapping from database."""
    # Import here to avoid daemon startup dependency ordering issues.
    from backend.app.config import get_settings
    from backend.app.db.session import create_session_factory
    from backend.app.models.peer import Peer

    settings = get_settings()
    session_factory = create_session_factory(settings.database_url)
    session = session_factory()
    try:
        peers = session.query(Peer).all()
        name_map: dict[str, int] = {}
        for peer in peers:
            name_map[peer.name] = peer.peerId
            # Also map the sanitized name so swanctl output can be resolved
            sanitized = _sanitize_name(peer.name)
            if sanitized != peer.name:
                name_map[sanitized] = peer.peerId
        return name_map
    finally:
        session.close()


def _resolve_peer_ids(peer_names: Iterable[str]) -> dict[str, int]:
    """Resolve peer names to IDs with a short-lived cache."""
    names = [name for name in peer_names if name]
    if not names:
        return {}

    global _PEER_NAME_CACHE, _PEER_CACHE_LAST_REFRESH
    now = time.monotonic()
    missing = any(name not in _PEER_NAME_CACHE for name in names)
    if missing or (now - _PEER_CACHE_LAST_REFRESH) > _PEER_CACHE_TTL_SECONDS:
        try:
            _PEER_NAME_CACHE = _load_peer_name_map()
            _PEER_CACHE_LAST_REFRESH = now
        except Exception as e:
            logger.error(f"Failed to refresh peer ID cache: {e}")
            return {}

    return {name: _PEER_NAME_CACHE[name] for name in names if name in _PEER_NAME_CACHE}


def generate_swanctl_config(
    name: str,
    remote_ip: str,
    psk: str,
    ike_version: str,
    dpd_action: str | None = "restart",
    dpd_delay: int | None = 30,
    dpd_timeout: int | None = 150,
    rekey_time: int | None = 3600,
    peer_id: int | None = None,
    local_ts: str | None = None,
    remote_ts: str | None = None,
) -> str:
    """Generate strongSwan swanctl configuration content for a peer.

    Args:
        name: Peer name (used as connection name).
        remote_ip: Remote endpoint IP address.
        psk: Pre-shared key (plaintext for config file).
        ike_version: IKE version number (ikev1 or ikev2).
        dpd_action: DPD action on timeout.
        dpd_delay: DPD delay in seconds.
        dpd_timeout: DPD timeout in seconds.
        rekey_time: SA rekey time in seconds.
        peer_id: Peer ID used as XFRM interface if_id (optional).
        local_ts: Local traffic selector (e.g. PT subnet CIDR).
        remote_ts: Remote traffic selector (e.g. comma-separated peer route CIDRs).

    Returns:
        Configuration file content string.
    """
    version_num = "2" if ike_version == "ikev2" else "1"
    safe_name = _sanitize_name(name)

    # Build optional if_id lines for XFRM interface binding
    if_id_lines = ""
    if peer_id is not None:
        if_id_lines = (
            f"\n                if_id_in = {peer_id}"
            f"\n                if_id_out = {peer_id}"
        )

    # Build optional traffic selector lines
    ts_lines = ""
    if local_ts:
        ts_lines += f"\n                local_ts = {local_ts}"
    if remote_ts:
        ts_lines += f"\n                remote_ts = {remote_ts}"

    config = f"""# Auto-generated by encryptor-sim daemon
# Peer: {name}
connections {{
    {safe_name} {{
        version = {version_num}
        remote_addrs = {remote_ip}
        dpd_delay = {dpd_delay or 30}s
        dpd_timeout = {dpd_timeout or 150}s
        local {{
            auth = psk
        }}
        remote {{
            auth = psk
        }}
        children {{
            {safe_name}-child {{
                mode = tunnel
                dpd_action = {dpd_action or 'restart'}
                rekey_time = {rekey_time or 3600}s{if_id_lines}{ts_lines}
            }}
        }}
    }}
}}

secrets {{
    ike-{safe_name} {{
        id-a = %any
        id-b = {remote_ip}
        secret = "{psk}"
    }}
}}
"""
    return config


def validate_swanctl_syntax(
    config_content: str,
    *,
    runner: Runner = subprocess.run,
) -> tuple[bool, str]:
    """Validate strongSwan configuration syntax.

    Uses swanctl --load-conns --dry-run style check if available,
    otherwise does basic syntax validation.

    Returns:
        Tuple of (is_valid, error_message).
    """
    # Basic syntax checks
    open_braces = config_content.count("{")
    close_braces = config_content.count("}")
    if open_braces != close_braces:
        return False, f"Brace mismatch: {open_braces} open, {close_braces} close"

    if "connections {" not in config_content:
        return False, "Missing 'connections' block"

    if "secrets {" not in config_content:
        return False, "Missing 'secrets' block"

    return True, ""


def write_peer_config(
    name: str,
    config_content: str,
    *,
    conf_dir: str = SWANCTL_CONF_DIR,
) -> Path:
    """Write peer configuration to swanctl conf.d directory.

    Args:
        name: Peer name (used for filename).
        config_content: Configuration file content.
        conf_dir: Configuration directory path.

    Returns:
        Path to the written config file.

    Raises:
        IOError: If config file cannot be written.
    """
    conf_path = Path(conf_dir)
    try:
        conf_path.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        logger.error(f"Failed to create config directory {conf_path}: {e}")
        raise IOError(f"Cannot create config directory: {e}") from e

    safe_name = _sanitize_name(name)
    config_file = conf_path / f"{safe_name}.conf"

    try:
        config_file.write_text(config_content)
    except OSError as e:
        logger.error(f"Failed to write config file {config_file}: {e}")
        raise IOError(f"Cannot write config file: {e}") from e

    logger.info(f"Wrote peer config: {config_file}")
    return config_file


def initiate_peer(
    name: str,
    *,
    runner: Runner = subprocess.run,
    load_conns_first: bool = True,
) -> dict[str, str]:
    """Initiate a tunnel for a peer.

    Brings up IKE/Child SAs via swanctl --initiate.
    Idempotent: succeeds if tunnel is already up or negotiating.

    Args:
        name: Peer/connection name.
        runner: Command runner.
        load_conns_first: Optionally reload connections before initiating.

    Returns:
        Status dict with result details.
    """
    load_warning: str | None = None
    # Reload connections and credentials to ensure latest config is loaded
    if load_conns_first:
        try:
            runner(
                _swanctl_cmd("--load-all"),
                capture_output=True,
                text=True,
                timeout=5,
            )
        except subprocess.TimeoutExpired:
            load_warning = "swanctl --load-all timed out"
        except FileNotFoundError:
            load_warning = "swanctl not available; skipping load-all"
        except Exception as e:
            load_warning = f"swanctl --load-all failed: {e}"

    safe_name = _sanitize_name(name)
    try:
        result = runner(
            _swanctl_cmd("--initiate", "--child", f"{safe_name}-child"),
            capture_output=True,
            text=True,
            timeout=5,
        )
        combined_output = "\n".join(
            part for part in (result.stderr, result.stdout) if part
        ).strip()
        output_for_idempotency = combined_output or ""
        if result.returncode == 0:
            # Check if already established (Task 1.3 - idempotency)
            if _is_already_established(output_for_idempotency):
                logger.info(f"Tunnel already established for peer {name}")
                response = {
                    "status": "success",
                    "message": f"Tunnel already established for peer {name}",
                }
                if load_warning:
                    response["warning"] = load_warning
                return response
            logger.info(f"Tunnel initiated for peer {name}")
            response = {
                "status": "success",
                "message": f"Tunnel initiated for peer {name}",
            }
            if load_warning:
                response["warning"] = load_warning
            return response
        # Non-zero return code may mean tunnel is already up
        logger.info(
            f"Tunnel initiation for peer {name} returned code {result.returncode}: "
            f"{result.stderr.strip()}"
        )
        if _is_already_established(output_for_idempotency):
            response = {
                "status": "success",
                "message": f"Tunnel already established for peer {name}",
            }
            if load_warning:
                response["warning"] = load_warning
            return response
        response = {
            "status": "error",
            "message": (
                f"Tunnel initiation failed for peer {name}: "
                f"{combined_output or f'Exit code {result.returncode}'}"
            ),
        }
        if load_warning:
            response["warning"] = load_warning
        return response
    except subprocess.TimeoutExpired:
        logger.warning(f"Tunnel initiation timed out for peer {name}")
        return {
            "status": "warning",
            "message": f"Tunnel initiation timed out for peer {name}, proceeding",
        }
    except FileNotFoundError:
        logger.warning("swanctl not found, skipping tunnel initiation")
        return {
            "status": "warning",
            "message": "swanctl not available, skipping initiation",
        }


def teardown_peer(
    name: str,
    peer_id: int | None = None,
    *,
    runner: Runner = subprocess.run,
) -> dict[str, str]:
    """Tear down an active tunnel for a peer.

    Sends IKE delete notification via swanctl --terminate.
    Idempotent: succeeds if tunnel is already down.

    Args:
        name: Peer/connection name.
        peer_id: Peer ID for XFRM interface cleanup.
        runner: Command runner.

    Returns:
        Status dict with result details.
    """
    safe_name = _sanitize_name(name)
    try:
        result = runner(
            _swanctl_cmd("--terminate", "--child", f"{safe_name}-child"),
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            logger.info(f"Tunnel torn down for peer {name}")
            response = {
                "status": "success",
                "message": f"Tunnel torn down for peer {name}",
            }
        else:
            # Non-zero return code may mean tunnel was already down
            logger.info(
                f"Tunnel teardown for peer {name} returned code {result.returncode}: "
                f"{result.stderr.strip()}"
            )
            response = {
                "status": "success",
                "message": f"Tunnel already down or not found for peer {name}",
            }
    except subprocess.TimeoutExpired:
        logger.warning(f"Tunnel teardown timed out for peer {name}")
        response = {
            "status": "success",
            "message": f"Tunnel teardown timed out for peer {name}, proceeding",
        }
    except FileNotFoundError:
        logger.warning("swanctl not found, skipping tunnel teardown")
        response = {
            "status": "success",
            "message": "swanctl not available, skipping teardown",
        }

    # Clean up XFRM interface
    if peer_id is not None:
        try:
            from backend.daemon.ops.xfrm_ops import delete_xfrm_interface

            delete_xfrm_interface(peer_id, runner=runner)
        except Exception as e:
            logger.warning(f"Failed to delete XFRM interface for peer {name}: {e}")

    return response


def remove_peer_config(
    name: str,
    *,
    conf_dir: str = SWANCTL_CONF_DIR,
) -> dict[str, str]:
    """Remove a peer's strongSwan configuration file.

    Idempotent: succeeds if file doesn't exist.

    Args:
        name: Peer name (used for filename).
        conf_dir: Configuration directory path.

    Returns:
        Status dict with result details.
    """
    safe_name = _sanitize_name(name)
    config_file = Path(conf_dir) / f"{safe_name}.conf"

    if not config_file.exists():
        logger.info(f"Config file already removed: {config_file}")
        return {
            "status": "success",
            "message": f"Configuration file already removed: {config_file}",
        }

    try:
        config_file.unlink()
        logger.info(f"Removed peer config: {config_file}")
        return {
            "status": "success",
            "message": f"Configuration file removed: {config_file}",
        }
    except OSError as e:
        logger.error(f"Failed to remove config file {config_file}: {e}")
        return {
            "status": "error",
            "message": f"Failed to remove config file: {e}",
        }


def write_routes_config(
    name: str,
    routes: list[dict[str, str]],
    *,
    local_subnet: str | None = None,
    conf_dir: str = SWANCTL_CONF_DIR,
) -> dict[str, str]:
    """Update a peer's strongSwan config with traffic selectors.

    Sets local_ts to the local PT subnet and remote_ts to the
    comma-separated CIDRs from the peer's routes list.

    Args:
        name: Peer name (matches config filename).
        routes: List of route dicts with 'destination_cidr' key.
        local_subnet: Local PT subnet CIDR for local_ts (optional).
        conf_dir: Configuration directory path.

    Returns:
        Status dict with result details.
    """
    safe_name = _sanitize_name(name)
    config_file = Path(conf_dir) / f"{safe_name}.conf"

    if not config_file.exists():
        logger.warning(f"Peer config file not found: {config_file}")
        return {
            "status": "success",
            "message": f"Peer config file not found: {config_file}. Routes saved to database only.",
        }

    remote_cidrs = ",".join(r["destination_cidr"] for r in routes)
    if not remote_cidrs:
        remote_cidrs = "0.0.0.0/0"

    try:
        content = config_file.read_text()

        # Update remote_ts (peer routes)
        content = _upsert_ts_directive(content, "remote_ts", remote_cidrs)

        # Update local_ts (local PT subnet) if available
        if local_subnet:
            content = _upsert_ts_directive(content, "local_ts", local_subnet)

        config_file.write_text(content)
        logger.info(
            f"Updated traffic selectors for peer {name}: "
            f"local_ts={local_subnet or 'unchanged'}, remote_ts={remote_cidrs}"
        )

        return {
            "status": "success",
            "message": f"Routes configured for peer {name}",
            "config_file": str(config_file),
        }
    except OSError as e:
        logger.error(f"Failed to update routes config for {name}: {e}")
        return {
            "status": "error",
            "message": f"Failed to update routes config: {e}",
        }


def _upsert_ts_directive(content: str, directive: str, value: str) -> str:
    """Update or insert a traffic selector directive in swanctl config content.

    Args:
        content: Existing config file content.
        directive: Directive name (e.g. "local_ts" or "remote_ts").
        value: Value to set.

    Returns:
        Updated config content.
    """
    if directive in content:
        # Replace existing directive line
        lines = content.split("\n")
        new_lines = []
        for line in lines:
            if directive in line and "=" in line:
                indent = line[: len(line) - len(line.lstrip())]
                new_lines.append(f"{indent}{directive} = {value}")
            else:
                new_lines.append(line)
        return "\n".join(new_lines)
    else:
        # Insert directive after "mode = tunnel" line
        lines = content.split("\n")
        new_lines = []
        inserted = False
        for line in lines:
            new_lines.append(line)
            if not inserted and "mode = tunnel" in line:
                indent = line[: len(line) - len(line.lstrip())]
                new_lines.append(f"{indent}{directive} = {value}")
                inserted = True
        return "\n".join(new_lines)


def reload_peer_config(
    name: str,
    *,
    runner: Runner = subprocess.run,
) -> dict[str, str]:
    """Reload peer connections and credentials without restarting tunnels.

    Uses swanctl --load-all to reload connections and secrets.

    Args:
        name: Peer name (for logging).
        runner: Command runner.

    Returns:
        Status dict with result details.
    """
    try:
        result = runner(
            _swanctl_cmd("--load-all"),
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            logger.info(f"Reloaded configuration after route update for {name}")
            return {
                "status": "success",
                "message": f"Configuration reloaded for peer {name}",
            }
        logger.warning(
            f"Configuration reload returned code {result.returncode}: {result.stderr.strip()}"
        )
        return {
            "status": "success",
            "message": f"Configuration reload returned code {result.returncode}",
        }
    except subprocess.TimeoutExpired:
        logger.warning("Configuration reload timed out")
        return {
            "status": "success",
            "message": "Configuration reload timed out, proceeding",
        }
    except FileNotFoundError:
        logger.warning("swanctl not found, skipping configuration reload")
        return {
            "status": "success",
            "message": "swanctl not available, skipping reload",
        }


def _parse_ike_state(state: str) -> str:
    """Map strongSwan IKE SA state to tunnel status value.

    Args:
        state: IKE SA state string from swanctl (e.g. ESTABLISHED, CONNECTING).

    Returns:
        One of: "up", "down", "negotiating", "unknown".
    """
    state_upper = state.upper()
    if state_upper == "ESTABLISHED":
        return "up"
    if state_upper in ("CONNECTING", "REKEYING"):
        return "negotiating"
    if state_upper in ("DELETING", "DESTROYING", "PASSIVE"):
        return "down"
    return "unknown"


def get_tunnel_status(
    *,
    runner: Runner = subprocess.run,
    peer_id_lookup: Callable[[Iterable[str]], dict[str, int]] | None = None,
) -> dict[int, str]:
    """Query strongSwan for tunnel status via swanctl --list-sas.

    Parses the output to extract IKE SA states per connection and
    maps them to status values: "up", "down", "negotiating", "unknown".

    Args:
        runner: Command runner (injectable for testing).

    Returns:
        Dict mapping peerId to status string.
    """
    try:
        result = runner(
            _swanctl_cmd("--list-sas"),
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode != 0:
            logger.error(
                f"swanctl --list-sas failed with code {result.returncode}: "
                f"{result.stderr.strip()}"
            )
            return {}

        name_status = _parse_list_sas_output(result.stdout)
        lookup = peer_id_lookup or _resolve_peer_ids
        name_to_id = lookup(name_status.keys())
        return {
            peer_id: status
            for name, status in name_status.items()
            if (peer_id := name_to_id.get(name)) is not None
        }
    except FileNotFoundError:
        logger.warning("swanctl not found, cannot query tunnel status")
        return {}
    except subprocess.TimeoutExpired:
        logger.warning("swanctl --list-sas timed out")
        return {}


def get_tunnel_telemetry(
    *,
    runner: Runner = subprocess.run,
    peer_id_lookup: Callable[[Iterable[str]], dict[str, int]] | None = None,
) -> dict[int, dict]:
    """Query strongSwan for tunnel telemetry via swanctl --list-sas.

    Parses the output to extract IKE SA states, establishment time,
    and traffic counters per connection.

    Args:
        runner: Command runner (injectable for testing).
        peer_id_lookup: Optional function to map peer names to IDs.

    Returns:
        Dict mapping peerId to telemetry dict containing:
        - status: str ("up", "down", "negotiating", "unknown")
        - establishedSec: int (seconds since establishment, 0 if not established)
        - bytesIn: int (bytes received)
        - bytesOut: int (bytes sent)
        - packetsIn: int (packets received)
        - packetsOut: int (packets sent)
    """
    try:
        result = runner(
            _swanctl_cmd("--list-sas"),
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode != 0:
            logger.error(
                f"swanctl --list-sas failed with code {result.returncode}: "
                f"{result.stderr.strip()}"
            )
            return {}

        name_telemetry = _parse_list_sas_telemetry(result.stdout)
        lookup = peer_id_lookup or _resolve_peer_ids
        name_to_id = lookup(name_telemetry.keys())
        return {
            peer_id: telemetry
            for name, telemetry in name_telemetry.items()
            if (peer_id := name_to_id.get(name)) is not None
        }
    except FileNotFoundError:
        logger.warning("swanctl not found, cannot query tunnel telemetry")
        return {}
    except subprocess.TimeoutExpired:
        logger.warning("swanctl --list-sas timed out")
        return {}


def _parse_list_sas_output(output: str) -> dict[str, str]:
    """Parse swanctl --list-sas output into a status dict.

    Expected format (each IKE SA on a non-indented line):
        conn-name: #N, STATE, IKEv2, ...

    Args:
        output: Raw stdout from swanctl --list-sas.

    Returns:
        Dict mapping connection name to status string.
    """
    status_map: dict[str, str] = {}

    for line in output.splitlines():
        # IKE SA lines start at column 0 (not indented)
        if line and not line[0].isspace() and ":" in line:
            # Format: "conn-name: #N, STATE, ..."
            name_part, _, rest = line.partition(":")
            name = name_part.strip()
            parts = [p.strip() for p in rest.split(",")]
            # State is the second CSV field (after #N)
            if len(parts) >= 2:
                state = parts[1]
                status_map[name] = _parse_ike_state(state)

    return status_map


def _parse_list_sas_telemetry(output: str) -> dict[str, dict]:
    """Parse swanctl --list-sas output into telemetry dicts.

    Expected format:
        conn-name: #N, STATE, IKEv2, ...
          established: 3600 seconds ago
          conn-name-child: #N, INSTALLED, TUNNEL
            bytes_in:  1024, bytes_out:  2048
            packets_in:  10, packets_out:  20

    Args:
        output: Raw stdout from swanctl --list-sas.

    Returns:
        Dict mapping connection name to telemetry dict with fields:
        status, establishedSec, bytesIn, bytesOut, packetsIn, packetsOut.
    """
    telemetry_map: dict[str, dict] = {}
    current_conn: str | None = None

    for line in output.splitlines():
        if not line:
            continue

        # IKE SA lines start at column 0 (not indented)
        if line and not line[0].isspace() and ":" in line:
            # Format: "conn-name: #N, STATE, ..."
            name_part, _, rest = line.partition(":")
            name = name_part.strip()
            parts = [p.strip() for p in rest.split(",")]

            # Initialize telemetry dict with defaults
            telemetry_map[name] = {
                "status": "unknown",
                "establishedSec": 0,
                "bytesIn": 0,
                "bytesOut": 0,
                "packetsIn": 0,
                "packetsOut": 0,
            }

            # Extract status from state field
            if len(parts) >= 2:
                state = parts[1]
                telemetry_map[name]["status"] = _parse_ike_state(state)

            current_conn = name

        # Indented lines contain telemetry data
        elif line and line[0].isspace() and current_conn:
            stripped = line.strip()

            # Parse "established: N seconds ago"
            if stripped.startswith("established:"):
                try:
                    # Extract number from "established: 3600 seconds ago"
                    parts = stripped.split()
                    if len(parts) >= 2:
                        sec = int(parts[1])
                        telemetry_map[current_conn]["establishedSec"] = sec
                except (ValueError, IndexError):
                    pass  # Default to 0

            # Parse traffic counters: "bytes_in:  1024, bytes_out:  2048"
            if "bytes_in:" in stripped or "bytes_out:" in stripped:
                for part in stripped.split(","):
                    part = part.strip()
                    if "bytes_in:" in part:
                        try:
                            val = int(part.split(":")[1].strip())
                            telemetry_map[current_conn]["bytesIn"] = val
                        except (ValueError, IndexError):
                            pass  # Default to 0
                    elif "bytes_out:" in part:
                        try:
                            val = int(part.split(":")[1].strip())
                            telemetry_map[current_conn]["bytesOut"] = val
                        except (ValueError, IndexError):
                            pass  # Default to 0

            # Parse packet counters: "packets_in:  10, packets_out:  20"
            if "packets_in:" in stripped or "packets_out:" in stripped:
                for part in stripped.split(","):
                    part = part.strip()
                    if "packets_in:" in part:
                        try:
                            val = int(part.split(":")[1].strip())
                            telemetry_map[current_conn]["packetsIn"] = val
                        except (ValueError, IndexError):
                            pass  # Default to 0
                    elif "packets_out:" in part:
                        try:
                            val = int(part.split(":")[1].strip())
                            telemetry_map[current_conn]["packetsOut"] = val
                        except (ValueError, IndexError):
                            pass  # Default to 0

    return telemetry_map


def configure_peer(
    name: str,
    remote_ip: str,
    psk: str,
    ike_version: str,
    dpd_action: str | None = "restart",
    dpd_delay: int | None = 30,
    dpd_timeout: int | None = 150,
    rekey_time: int | None = 3600,
    peer_id: int | None = None,
    *,
    conf_dir: str = SWANCTL_CONF_DIR,
    runner: Runner = subprocess.run,
) -> dict[str, str]:
    """Configure a peer in strongSwan.

    Generates configuration, validates syntax, writes to conf.d,
    and creates the XFRM interface if peer_id is provided.

    Args:
        name: Peer name.
        remote_ip: Remote IP address.
        psk: Pre-shared key (plaintext).
        ike_version: IKE version.
        dpd_action: DPD action.
        dpd_delay: DPD delay seconds.
        dpd_timeout: DPD timeout seconds.
        rekey_time: Rekey time seconds.
        peer_id: Peer ID for XFRM interface creation.
        conf_dir: Configuration directory.
        runner: Command runner.

    Returns:
        Status dict with result details.
    """
    # Look up local PT subnet for traffic selector
    local_ts = None
    try:
        from backend.daemon.ops.network_ops import get_pt_subnet

        local_ts = get_pt_subnet()
    except Exception:
        logger.debug("Could not look up PT subnet for local_ts")

    config_content = generate_swanctl_config(
        name=name,
        remote_ip=remote_ip,
        psk=psk,
        ike_version=ike_version,
        dpd_action=dpd_action,
        dpd_delay=dpd_delay,
        dpd_timeout=dpd_timeout,
        rekey_time=rekey_time,
        peer_id=peer_id,
        local_ts=local_ts,
    )

    is_valid, error_msg = validate_swanctl_syntax(config_content, runner=runner)
    if not is_valid:
        raise ValueError(f"Configuration syntax error: {error_msg}")

    config_file = write_peer_config(
        name=name, config_content=config_content, conf_dir=conf_dir
    )

    # Create XFRM interface for this peer
    if peer_id is not None:
        try:
            from backend.daemon.ops.xfrm_ops import create_xfrm_interface

            create_xfrm_interface(peer_id, peer_id, runner=runner)
        except Exception as e:
            logger.warning(f"Failed to create XFRM interface for peer {name}: {e}")

    return {
        "status": "success",
        "message": f"Peer configuration written to {config_file}",
        "config_file": str(config_file),
    }
