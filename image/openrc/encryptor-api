#!/sbin/openrc-run
# OpenRC service: encryptor-api
# FastAPI backend for the Encryptor Simulator web UI
#
# This service runs in the MGMT namespace for network isolation,
# ensuring the API is only accessible from the management interface.
# It communicates with the privileged daemon via Unix socket IPC.
#
# HTTPS is enforced using self-signed TLS certificate.

name="encryptor-api"
description="Encryptor Simulator REST API (HTTPS)"

# TLS certificate paths
SSL_CERTFILE="/etc/encryptor-sim/tls/server.crt"
SSL_KEYFILE="/etc/encryptor-sim/tls/server.key"

# Run API in MGMT namespace for isolation with HTTPS on port 443
# Port 443 requires root, so we stay as root but uvicorn runs the app
command="/sbin/ip"
command_args="netns exec ns_mgmt /usr/bin/python3 /opt/encryptor-sim/backend/uvicorn_server.py"
command_background="yes"

directory="/opt/encryptor-sim/backend"
pidfile="/run/${RC_SVCNAME}.pid"
start_stop_daemon_args="--make-pidfile --pidfile ${pidfile}"
output_log="/var/log/encryptor-sim/api.log"
error_log="/var/log/encryptor-sim/api.error.log"

# Environment variables (exported for the subprocess)
export ENCRYPTOR_ENV="production"
export ENCRYPTOR_DB_PATH="/var/lib/encryptor-sim/encryptor.db"
export ENCRYPTOR_DAEMON_SOCKET="/run/encryptor-sim/daemon.sock"
export APP_DAEMON_SOCKET_PATH="/run/encryptor-sim/daemon.sock"
export APP_SSL_CERTFILE="${SSL_CERTFILE}"
export APP_SSL_KEYFILE="${SSL_KEYFILE}"
export PYTHONPATH="/opt/encryptor-sim"

# Dependencies
depend() {
    need encryptor-daemon
    after networking encryptor-namespaces
}

start_pre() {
    if [ -f "$pidfile" ] && ! kill -0 "$(cat "$pidfile")" >/dev/null 2>&1; then
        rm -f "$pidfile"
    fi

    # Load PSK encryption key for API settings
    if [ -f /etc/encryptor-sim/psk.key ]; then
        export APP_PSK_ENCRYPTION_KEY="$(cat /etc/encryptor-sim/psk.key)"
    else
        eerror "PSK encryption key not found at /etc/encryptor-sim/psk.key"
        return 1
    fi

    # Load JWT secret for Settings.secret_key
    if [ -f /etc/encryptor-sim/jwt.key ]; then
        export APP_SECRET_KEY="$(cat /etc/encryptor-sim/jwt.key)"
    else
        eerror "JWT secret key not found at /etc/encryptor-sim/jwt.key"
        return 1
    fi

    # Ensure application group exists
    if ! getent group encryptor >/dev/null 2>&1; then
        einfo "Creating encryptor group"
        addgroup -S encryptor || { eerror "Failed to create encryptor group"; return 1; }
    fi

    # Ensure application user exists
    if ! id -u encryptor >/dev/null 2>&1; then
        einfo "Creating encryptor user"
        adduser -D -H -s /sbin/nologin -G encryptor encryptor || { eerror "Failed to create encryptor user"; return 1; }
    fi

    # Ensure log directory exists with correct permissions
    checkpath --directory --owner encryptor:encryptor --mode 0755 /var/log/encryptor-sim

    # Ensure data directory exists with correct permissions
    checkpath --directory --owner encryptor:encryptor --mode 0750 /var/lib/encryptor-sim

    # Ensure frontend build exists
    if [ ! -f /opt/encryptor-sim/backend/static/index.html ]; then
        eerror "Frontend build missing: /opt/encryptor-sim/backend/static/index.html"
        return 1
    fi

    # Verify daemon socket is available
    if [ ! -S /run/encryptor-sim/daemon.sock ]; then
        ewarn "Daemon socket not found, daemon may not be running"
    fi

    # Enforce HTTPS-only on MGMT by failing if HTTP listener exists
    if command -v ss >/dev/null 2>&1; then
        if ip netns exec ns_mgmt ss -ltn "sport = :80" 2>/dev/null | grep -q ":80"; then
            eerror "HTTP listener detected on port 80 in ns_mgmt"
            return 1
        fi
    else
        ewarn "ss not available; cannot verify HTTP listener on port 80"
    fi

    return 0
}

start_post() {
    # Wait for uvicorn to bind to port 443 in ns_mgmt.
    # We check the listening socket rather than hitting the /health endpoint
    # because that endpoint requires authentication.
    local tries=0
    local max_tries=30
    while [ $tries -lt $max_tries ]; do
        if ip netns exec ns_mgmt ss -ltn 2>/dev/null | grep -q ":443 "; then
            # Record boot complete timestamp (Story 2.5: Boot Health Indicator)
            # API is now ready to accept requests - boot sequence complete
            mkdir -p /var/run/encryptor
            if [ ! -f /var/run/encryptor/boot-start ]; then
                ewarn "boot-start timestamp missing; creating fallback timestamp"
                date +%s.%N > /var/run/encryptor/boot-start
            fi
            date +%s.%N > /var/run/encryptor/boot-complete
            einfo "API listening on port 443 after ${tries}s"
            return 0
        fi
        sleep 1
        tries=$((tries + 1))
    done
    eerror "API not listening on port 443 after ${max_tries}s"
    return 1
}

healthcheck() {
    # Check if uvicorn is listening on port 443 in ns_mgmt namespace
    ip netns exec ns_mgmt ss -ltn 2>/dev/null | grep -q ":443 " || return 1
    return 0
}

